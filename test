using System;
using System.IO;
using System.Collections.Generic;
using Microsoft.SqlServer.TransactSql.ScriptDom;
using Microsoft.SqlServer.Dts.Runtime;

public void Main()
{
    string inputFile = Dts.Variables["User::InputFilePath"].Value.ToString();
    string outputFile = Dts.Variables["User::OutputFilePath"].Value.ToString();

    string fullSql = File.ReadAllText(inputFile);

    // Split on GO (standalone GO only)
    string[] procedures = System.Text.RegularExpressions.Regex.Split(
        fullSql,
        @"^\s*GO\s*$",
        System.Text.RegularExpressions.RegexOptions.IgnoreCase |
        System.Text.RegularExpressions.RegexOptions.Multiline
    );

    var finalResults = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

    foreach (string spText in procedures)
    {
        if (string.IsNullOrWhiteSpace(spText))
            continue;

        IList<ParseError> errors;
        var parser = new TSql150Parser(false);
        var fragment = parser.Parse(new StringReader(spText), out errors);

        if (errors.Count > 0)
            continue; // Skip invalid blocks safely

        var visitor = new LineageVisitor();
        fragment.Accept(visitor);

        foreach (var r in visitor.Results)
            finalResults.Add(r);
    }

    File.WriteAllLines(outputFile, finalResults);
    Dts.TaskResult = (int)ScriptResults.Success;
}





using System;
using System.Collections.Generic;
using Microsoft.SqlServer.TransactSql.ScriptDom;

public class LineageVisitor : TSqlFragmentVisitor
{
    private string currentProcedure = "UNKNOWN";
    private Dictionary<string, string> tableAliases =
        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

    public HashSet<string> Results =
        new HashSet<string>(StringComparer.OrdinalIgnoreCase);

    public override void Visit(CreateProcedureStatement node)
    {
        currentProcedure = node.ProcedureReference.Name.BaseIdentifier.Value;
        tableAliases.Clear(); // VERY IMPORTANT
        base.Visit(node);
    }

    public override void Visit(NamedTableReference node)
    {
        string tableName = node.SchemaObject.BaseIdentifier.Value;

        if (node.Alias != null)
        {
            tableAliases[node.Alias.Value] = tableName;
        }
        else
        {
            tableAliases[tableName] = tableName;
        }

        base.Visit(node);
    }

    public override void Visit(ColumnReferenceExpression node)
    {
        if (node.MultiPartIdentifier?.Identifiers.Count == 2)
        {
            string alias = node.MultiPartIdentifier.Identifiers[0].Value;
            string column = node.MultiPartIdentifier.Identifiers[1].Value;

            if (tableAliases.ContainsKey(alias))
            {
                Results.Add(
                    $"Procedure: {currentProcedure} | Table: {tableAliases[alias]} | Column: {column}"
                );
            }
        }

        base.Visit(node);
    }
}
