using System;
using System.IO;
using System.Collections.Generic;
using System.Text;
using Microsoft.SqlServer.TransactSql.ScriptDom;
using Microsoft.SqlServer.Dts.Runtime;

public void Main()
{
    string inputFile = Dts.Variables["User::InputFilePath"].Value.ToString();
    string outputFile = Dts.Variables["User::OutputFilePath"].Value.ToString();

    string fullSql = File.ReadAllText(inputFile);

    string[] procedures = System.Text.RegularExpressions.Regex.Split(
        fullSql,
        @"^\s*GO\s*$",
        System.Text.RegularExpressions.RegexOptions.IgnoreCase |
        System.Text.RegularExpressions.RegexOptions.Multiline
    );

    var finalOutput = new StringBuilder();

    foreach (string spText in procedures)
    {
        if (string.IsNullOrWhiteSpace(spText))
            continue;

        IList<ParseError> errors;
        var parser = new TSql150Parser(false);
        var fragment = parser.Parse(new StringReader(spText), out errors);

        if (errors.Count > 0)
            continue;

        var visitor = new LineageVisitor();
        fragment.Accept(visitor);

        if (!visitor.HasContent())
            continue;

        finalOutput.AppendLine($"Stored Procedure: {visitor.ProcedureName}");

        foreach (var table in visitor.TableColumnMap)
        {
            finalOutput.AppendLine($"  Table: {table.Key}");
            foreach (var col in table.Value)
            {
                finalOutput.AppendLine($"    - {col}");
            }
        }

        if (visitor.UnresolvedColumns.Count > 0)
        {
            finalOutput.AppendLine("  Unresolved Columns:");
            foreach (var col in visitor.UnresolvedColumns)
            {
                finalOutput.AppendLine($"    - {col}");
            }
        }

        finalOutput.AppendLine();
    }

    File.WriteAllText(outputFile, finalOutput.ToString());
    Dts.TaskResult = (int)ScriptResults.Success;
}

using System;
using System.Collections.Generic;
using Microsoft.SqlServer.TransactSql.ScriptDom;

public class LineageVisitor : TSqlFragmentVisitor
{
    public string ProcedureName = "UNKNOWN";

    private Dictionary<string, string> tableAliases =
        new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

    public Dictionary<string, HashSet<string>> TableColumnMap =
        new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);

    public HashSet<string> UnresolvedColumns =
        new HashSet<string>(StringComparer.OrdinalIgnoreCase);

    public override void Visit(CreateProcedureStatement node)
    {
        ProcedureName = node.ProcedureReference.Name.BaseIdentifier.Value;
        tableAliases.Clear();
        base.Visit(node);
    }

    public override void Visit(NamedTableReference node)
    {
        string tableName = node.SchemaObject.BaseIdentifier.Value;

        if (node.Alias != null)
            tableAliases[node.Alias.Value] = tableName;
        else
            tableAliases[tableName] = tableName;

        if (!TableColumnMap.ContainsKey(tableName))
            TableColumnMap[tableName] = new HashSet<string>();

        base.Visit(node);
    }

    public override void Visit(ColumnReferenceExpression node)
    {
        var identifiers = node.MultiPartIdentifier?.Identifiers;

        // alias.column
        if (identifiers != null && identifiers.Count == 2)
        {
            string alias = identifiers[0].Value;
            string column = identifiers[1].Value;

            if (tableAliases.ContainsKey(alias))
            {
                string table = tableAliases[alias];
                TableColumnMap[table].Add(column);
            }
            else
            {
                UnresolvedColumns.Add($"{alias}.{column}");
            }
        }
        // column only
        else if (identifiers != null && identifiers.Count == 1)
        {
            UnresolvedColumns.Add(identifiers[0].Value);
        }

        base.Visit(node);
    }

    public bool HasContent()
    {
        return TableColumnMap.Count > 0 || UnresolvedColumns.Count > 0;
    }
}

