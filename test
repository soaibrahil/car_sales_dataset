using System;
using System.IO;
using System.Collections.Generic;
using Microsoft.SqlServer.TransactSql.ScriptDom;
using Microsoft.SqlServer.Dts.Runtime;

public void Main()
{
    string inputFile = @"C:\Temp\input_sp.txt";
    string outputFile = @"C:\Temp\output_lineage.csv";

    string fullSql = File.ReadAllText(inputFile);

    string[] procedures = System.Text.RegularExpressions.Regex.Split(
        fullSql,
        @"^\s*GO\s*$",
        System.Text.RegularExpressions.RegexOptions.IgnoreCase |
        System.Text.RegularExpressions.RegexOptions.Multiline
    );

    var rows = new List<string>();
    rows.Add("StoredProcedureName,Schema,Table,Column");

    foreach (string spText in procedures)
    {
        if (string.IsNullOrWhiteSpace(spText))
            continue;

        IList<ParseError> errors;
        var parser = new TSql150Parser(false);
        var fragment = parser.Parse(new StringReader(spText), out errors);

        if (errors.Count > 0)
            continue;

        var visitor = new LineageVisitor();
        fragment.Accept(visitor);

        foreach (var r in visitor.Results)
            rows.Add(r);
    }

    File.WriteAllLines(outputFile, rows);
    Dts.TaskResult = (int)ScriptResults.Success;
}

------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using Microsoft.SqlServer.TransactSql.ScriptDom;

public class LineageVisitor : TSqlFragmentVisitor
{
    private string procedureName = "UNKNOWN";

    // alias -> (schema, table)
    private Dictionary<string, (string Schema, string Table)> aliasMap =
        new Dictionary<string, (string, string)>(StringComparer.OrdinalIgnoreCase);

    // Dedup: SP|Schema|Table|Column
    private HashSet<string> dedup =
        new HashSet<string>(StringComparer.OrdinalIgnoreCase);

    public List<string> Results = new List<string>();

    public override void Visit(CreateProcedureStatement node)
    {
        procedureName = node.ProcedureReference.Name.BaseIdentifier.Value;
        aliasMap.Clear();   // RESET PER SP (THIS IS CRITICAL)
        base.Visit(node);
    }

    public override void Visit(NamedTableReference node)
    {
        string schema = "unknown";
        string table = "unknown";

        if (node.SchemaObject != null)
        {
            var ids = node.SchemaObject.Identifiers;

            if (ids.Count == 2)
            {
                schema = ids[0].Value;
                table = ids[1].Value;
            }
            else if (ids.Count == 1)
            {
                table = ids[0].Value;
            }
        }

        string alias = node.Alias != null ? node.Alias.Value : table;

        // Store alias â†’ actual table
        aliasMap[alias] = (schema, table);

        base.Visit(node);
    }

    public override void Visit(ColumnReferenceExpression node)
    {
        var ids = node.MultiPartIdentifier?.Identifiers;
        if (ids == null)
            return;

        string schema = "unknown";
        string table = "unknown";
        string column;

        // alias.column
        if (ids.Count == 2)
        {
            string alias = ids[0].Value;
            column = ids[1].Value;

            if (aliasMap.TryGetValue(alias, out var tbl))
            {
                schema = tbl.Schema;
                table = tbl.Table;
            }
        }
        // column only
        else if (ids.Count == 1)
        {
            column = ids[0].Value;
        }
        else
        {
            return;
        }

        string row = $"{procedureName},{schema},{table},{column}";

        if (dedup.Add(row))
            Results.Add(row);

        base.Visit(node);
    }
}
