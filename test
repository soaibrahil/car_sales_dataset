using System;
using System.IO;
using System.Collections.Generic;
using Microsoft.SqlServer.TransactSql.ScriptDom;
using Microsoft.SqlServer.Dts.Runtime;

public void Main()
{
    string inputFile = @"C:\Temp\input_sp.txt";
    string outputFile = @"C:\Temp\output_lineage.csv";

    string fullSql = File.ReadAllText(inputFile);

    string[] procedures = System.Text.RegularExpressions.Regex.Split(
        fullSql,
        @"^\s*GO\s*$",
        System.Text.RegularExpressions.RegexOptions.IgnoreCase |
        System.Text.RegularExpressions.RegexOptions.Multiline
    );

    var rows = new List<string>();
    rows.Add("StoredProcedureName,Schema,Table,Column");

    foreach (string spText in procedures)
    {
        if (string.IsNullOrWhiteSpace(spText))
            continue;

        IList<ParseError> errors;
        var parser = new TSql150Parser(false);
        var fragment = parser.Parse(new StringReader(spText), out errors);

        if (errors.Count > 0)
            continue;

        var visitor = new LineageVisitor();
        fragment.Accept(visitor);

        foreach (var r in visitor.Results)
            rows.Add(r);
    }

    File.WriteAllLines(outputFile, rows);
    Dts.TaskResult = (int)ScriptResults.Success;
}

------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Microsoft.SqlServer.TransactSql.ScriptDom;

public class LineageVisitor : TSqlFragmentVisitor
{
    private string procedureName = "UNKNOWN";

    // alias -> (schema, table)
    private Dictionary<string, (string Schema, string Table)> tableAliases =
        new Dictionary<string, (string, string)>(StringComparer.OrdinalIgnoreCase);

    public List<string> Results = new List<string>();

    public override void Visit(CreateProcedureStatement node)
    {
        procedureName = node.ProcedureReference.Name.BaseIdentifier.Value;
        tableAliases.Clear();
        base.Visit(node);
    }

    public override void Visit(NamedTableReference node)
    {
        string schema = "unknown";
        string table = "unknown";

        if (node.SchemaObject != null)
        {
            var ids = node.SchemaObject.Identifiers;

            if (ids.Count == 2)
            {
                schema = ids[0].Value;
                table = ids[1].Value;
            }
            else if (ids.Count == 1)
            {
                table = ids[0].Value;
            }
        }

        // Alias is ONLY for lookup, never for output
        string alias = node.Alias != null ? node.Alias.Value : table;

        tableAliases[alias] = (schema, table);

        base.Visit(node);
    }

    public override void Visit(ColumnReferenceExpression node)
    {
        var ids = node.MultiPartIdentifier?.Identifiers;

        // alias.column
        if (ids != null && ids.Count == 2)
        {
            string alias = ids[0].Value;
            string column = ids[1].Value;

            if (tableAliases.TryGetValue(alias, out var tableInfo))
            {
                Results.Add(
                    $"{procedureName},{tableInfo.Schema},{tableInfo.Table},{column}"
                );
            }
            else
            {
                Results.Add(
                    $"{procedureName},unknown,unknown,{column}"
                );
            }
        }
        // column only
        else if (ids != null && ids.Count == 1)
        {
            Results.Add(
                $"{procedureName},unknown,unknown,{ids[0].Value}"
            );
        }

        base.Visit(node);
    }
}
